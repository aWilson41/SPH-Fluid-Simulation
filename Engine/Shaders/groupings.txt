// Point Shader
// Requires: Position buffer, uniform mvp, uniform material
pointVS.glsl
pointFS.glsl

// Color Shader
// Requires: Position buffer, color buffer, uniform mvp
colorVS.glsl
colorFS.glsl

// Tex3 Shader
// Requires: Position buffer, tex coord buffer, uniform mvp, uniform 3 comp texture
texVS.glsl
tex3FS.glsl

// Tex1 Shader
// Requires: Position buffer, tex coord buffer, uniform mvp, uniform 1 comp texture
texVS.glsl
tex1FS.glsl

// Normal Shader
// Requires: Position buffer, normal buffer, uniform mvp, uniform material, uniform vec3 directional light
normalVS.glsl
normalFS.glsl

// NormalColor Shader
// Requires: Position buffer, normal buffer, color buffer, uniform mvp, uniform vec3 directional light
normalColorVS.glsl
normalColorFS.glsl

// NormalTex3 Shader
// Requires: Position buffer, normal buffer, uniform mvp, uniform vec3 directional light, uniform 3 comp texture
normalTexVS.glsl
normalTex3FS.glsl

You must define a shader layout for the mapper, you can do this in the constructor. This just defines how the data is placed on the GPU. One mapper can utilize numerous layouts and switch between them.

The renderer then assigns shaders to use with the mappers given the desired layout. So a (mapper type, layout, renderer type) is mapped to a shader.

For example, the shaders assigned by the standard Renderer are different than those assigned by the PathTraceRenderer. But the layout is the same.


Default layout spec:
Vertex Shaders:
inVPos 0
inVNormal 1
inVTexCoord 2
inVColor 3
inVOffset 4
Fragment Shaders:
inFPos 0
inFNormal 1
inFTexCoord 2
inFColor 3
inFOffset 4